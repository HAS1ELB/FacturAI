#!/usr/bin/env python3
"""
üß™ Test d'Installation - FacturAI Fine-Tuning
V√©rifie que tous les composants sont correctement install√©s et fonctionnels
"""

import sys
import os
import json
import time
from pathlib import Path
import logging

logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

def test_python_version():
    """Test de la version Python"""
    logger.info("üêç Test version Python...")
    
    if sys.version_info >= (3, 8):
        logger.info(f"‚úÖ Python {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro} OK")
        return True
    else:
        logger.error(f"‚ùå Python {sys.version_info.major}.{sys.version_info.minor} trop ancien (requis: 3.8+)")
        return False

def test_core_dependencies():
    """Test des d√©pendances principales"""
    logger.info("üì¶ Test des d√©pendances principales...")
    
    dependencies = {
        'numpy': 'numpy',
        'opencv-python': 'cv2',
        'pillow': 'PIL',
        'matplotlib': 'matplotlib',
        'pandas': 'pandas',
        'scikit-learn': 'sklearn'
    }
    
    failed = []
    
    for package, import_name in dependencies.items():
        try:
            __import__(import_name)
            logger.info(f"‚úÖ {package} OK")
        except ImportError:
            logger.error(f"‚ùå {package} manquant")
            failed.append(package)
    
    return len(failed) == 0

def test_ml_dependencies():
    """Test des d√©pendances ML/Deep Learning"""
    logger.info("ü§ñ Test des d√©pendances ML...")
    
    # PyTorch
    try:
        import torch
        logger.info(f"‚úÖ PyTorch {torch.__version__} OK")
        
        if torch.cuda.is_available():
            gpu_name = torch.cuda.get_device_name(0)
            logger.info(f"üéÆ GPU disponible: {gpu_name}")
        else:
            logger.warning("‚ö†Ô∏è Pas de GPU CUDA disponible (CPU seulement)")
    except ImportError:
        logger.error("‚ùå PyTorch manquant")
        return False
    
    # Transformers
    try:
        import transformers
        logger.info(f"‚úÖ Transformers {transformers.__version__} OK")
    except ImportError:
        logger.error("‚ùå Transformers manquant")
        return False
    
    return True

def test_ocr_dependencies():
    """Test des d√©pendances OCR"""
    logger.info("üëÅÔ∏è Test des d√©pendances OCR...")
    
    # EasyOCR
    try:
        import easyocr
        logger.info("‚úÖ EasyOCR OK")
    except ImportError:
        logger.error("‚ùå EasyOCR manquant")
        return False
    
    # PaddleOCR
    try:
        from paddleocr import PaddleOCR
        logger.info("‚úÖ PaddleOCR OK")
    except ImportError:
        logger.warning("‚ö†Ô∏è PaddleOCR manquant (optionnel)")
    
    # Tesseract
    try:
        import pytesseract
        logger.info("‚úÖ Pytesseract OK")
    except ImportError:
        logger.warning("‚ö†Ô∏è Pytesseract manquant (optionnel)")
    
    return True

def test_data_structure():
    """Test de la structure des donn√©es"""
    logger.info("üìÅ Test de la structure des donn√©es...")
    
    # V√©rifier les dossiers requis
    required_dirs = [
        "Data/processed_images",
        "Data/ocr_results"
    ]
    
    issues = []
    
    for dir_path in required_dirs:
        path = Path(dir_path)
        if not path.exists():
            issues.append(f"Dossier manquant: {dir_path}")
            logger.warning(f"‚ö†Ô∏è {dir_path} n'existe pas")
        else:
            logger.info(f"‚úÖ {dir_path} OK")
            
            # Compter les fichiers
            if "images" in dir_path:
                images = list(path.glob("*.png")) + list(path.glob("*.jpg"))
                logger.info(f"  üì∑ {len(images)} images trouv√©es")
            elif "ocr_results" in dir_path:
                json_files = list(path.glob("*.json"))
                logger.info(f"  üìÑ {len(json_files)} fichiers JSON trouv√©s")
    
    return len(issues) == 0

def test_module_imports():
    """Test d'import des modules du projet"""
    logger.info("üîß Test des modules du projet...")
    
    modules = [
        'fine-tuning-ocr/data_preparation/data_preparation',
        'fine-tuning-ocr/fine_tuning_manager/fine_tuning_manager',
        'fine-tuning-ocr/evaluation/model_evaluation',
        'fine-tuning-ocr/fine_tuning_model/easyocr_finetuning',
        'fine-tuning-ocr/fine_tuning_model/trocr_finetuning'
    ]
    
    failed = []
    
    for module in modules:
        try:
            if Path(f"{module}.py").exists():
                # Test syntaxique seulement
                with open(f"{module}.py", 'r', encoding='utf-8') as f:
                    compile(f.read(), f"{module}.py", 'exec')
                logger.info(f"‚úÖ {module}.py OK")
            else:
                logger.warning(f"‚ö†Ô∏è {module}.py non trouv√©")
                failed.append(module)
        except SyntaxError as e:
            logger.error(f"‚ùå {module}.py erreur syntaxe: {e}")
            failed.append(module)
        except Exception as e:
            logger.error(f"‚ùå {module}.py erreur: {e}")
            failed.append(module)
    
    return len(failed) == 0

def test_quick_functionality():
    """Test rapide de fonctionnalit√©"""
    logger.info("‚ö° Test de fonctionnalit√© rapide...")
    
    try:
        # Test cr√©ation d'un dataset factice
        from data_preparation.data_preparation import InvoiceDataPreparator
        
        # Cr√©er un dossier de test temporaire
        test_dir = Path("test_temp")
        test_dir.mkdir(exist_ok=True)
        
        # Test d'initialisation
        preparator = InvoiceDataPreparator(
            images_dir="Data/processed_images",
            ocr_results_dir="Data/ocr_results", 
            output_dir=str(test_dir)
        )
        
        logger.info("‚úÖ Module data_preparation fonctionnel")
        
        # Nettoyer
        import shutil
        shutil.rmtree(test_dir, ignore_errors=True)
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Test fonctionnel √©chou√©: {e}")
        return False

def test_gpu_functionality():
    """Test sp√©cifique du GPU pour l'entra√Ænement"""
    logger.info("üéÆ Test de fonctionnalit√© GPU...")
    
    try:
        import torch
        
        if not torch.cuda.is_available():
            logger.warning("‚ö†Ô∏è CUDA non disponible - CPU seulement")
            return True
        
        # Test simple GPU
        device = torch.device('cuda')
        x = torch.randn(10, 10).to(device)
        y = torch.randn(10, 10).to(device)
        z = torch.mm(x, y)
        
        logger.info(f"‚úÖ GPU fonctionnel: {torch.cuda.get_device_name(0)}")
        logger.info(f"üìä M√©moire GPU: {torch.cuda.get_device_properties(0).total_memory / 1e9:.1f}GB")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Test GPU √©chou√©: {e}")
        return False

def generate_installation_report():
    """G√©n√®re un rapport d'installation"""
    logger.info("üìä G√©n√©ration du rapport d'installation...")
    
    report = {
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
        "platform": sys.platform,
        "tests": {}
    }
    
    # Ex√©cuter tous les tests
    tests = [
        ("python_version", test_python_version),
        ("core_dependencies", test_core_dependencies),
        ("ml_dependencies", test_ml_dependencies),
        ("ocr_dependencies", test_ocr_dependencies),
        ("data_structure", test_data_structure),
        ("module_imports", test_module_imports),
        ("quick_functionality", test_quick_functionality),
        ("gpu_functionality", test_gpu_functionality)
    ]
    
    all_passed = True
    
    for test_name, test_func in tests:
        try:
            result = test_func()
            report["tests"][test_name] = {"passed": result, "error": None}
            if not result:
                all_passed = False
        except Exception as e:
            report["tests"][test_name] = {"passed": False, "error": str(e)}
            all_passed = False
            logger.error(f"‚ùå Test {test_name} a √©chou√©: {e}")
    
    # Sauvegarder le rapport
    report_file = "fine-tuning-ocr/installation_test_report.json"
    with open(report_file, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    logger.info(f"üìÑ Rapport sauvegard√©: {report_file}")
    
    return all_passed, report

def print_summary(all_passed, report):
    """Affiche le r√©sum√© des tests"""
    print("\n" + "="*60)
    print("üìä R√âSUM√â DES TESTS D'INSTALLATION")
    print("="*60)
    
    if all_passed:
        print("üéâ TOUS LES TESTS ONT R√âUSSI!")
        print("‚úÖ Votre installation est pr√™te pour le fine-tuning OCR")
    else:
        print("‚ö†Ô∏è CERTAINS TESTS ONT √âCHOU√â")
        print("‚ùå Veuillez corriger les probl√®mes avant de continuer")
    
    print(f"\nüìç Plateforme: {report['platform']}")
    print(f"üêç Python: {report['python_version']}")
    print(f"‚è∞ Test√© le: {report['timestamp']}")
    
    print("\nüìã D√âTAILS DES TESTS:")
    for test_name, result in report["tests"].items():
        status = "‚úÖ" if result["passed"] else "‚ùå"
        print(f"  {status} {test_name}")
        if result["error"]:
            print(f"      Erreur: {result['error']}")
    
    if not all_passed:
        print("\nüîß ACTIONS RECOMMAND√âES:")
        print("1. Installez les d√©pendances manquantes:")
        print("   python install_fine_tuning_deps.py")
        print("2. V√©rifiez la structure des dossiers:")
        print("   mkdir -p Data/processed_images Data/ocr_results")
        print("3. Consultez le guide d'installation:")
        print("   cat GUIDE_FINE_TUNING_COMPLET.md")
    else:
        print("\nüöÄ PROCHAINES √âTAPES:")
        print("1. Placez vos images dans Data/processed_images/")
        print("2. Placez vos r√©sultats OCR dans Data/ocr_results/")
        print("3. Lancez le fine-tuning:")
        print("   python quick_start.py --full-pipeline")

def main():
    """Fonction principale"""
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                üß™ Test d'Installation FacturAI              ‚ïë
    ‚ïë                  Fine-Tuning OCR System                      ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    logger.info("üöÄ D√©marrage des tests d'installation...")
    
    # Ex√©cuter tous les tests et g√©n√©rer le rapport
    all_passed, report = generate_installation_report()
    
    # Afficher le r√©sum√©
    print_summary(all_passed, report)
    
    # Code de sortie
    sys.exit(0 if all_passed else 1)

if __name__ == "__main__":
    main()